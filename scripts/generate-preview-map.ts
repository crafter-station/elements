#!/usr/bin/env bun

/**
 * Automatically generates component preview mappings from registry files.
 * This script reads all registry.json files and creates static imports
 * that Next.js can analyze at build time.
 */

import { existsSync, readFileSync, writeFileSync } from "fs";
import { join } from "path";

interface RegistryFile {
  path: string;
  type: string;
}

interface RegistryItem {
  name: string;
  type: string;
  files?: RegistryFile[];
}

interface Registry {
  items: RegistryItem[];
}

const PACKAGES_DIR = join(process.cwd(), "packages");
const OUTPUT_FILE = join(
  process.cwd(),
  "apps/web/lib/component-preview-map.generated.tsx",
);

const providers = ["clerk", "polar", "theme", "uploadthing", "logos"];

console.log("ðŸ” Scanning registries for previewable components...\n");

const imports: string[] = [];
const mappings: string[] = [];

for (const provider of providers) {
  const registryPath = join(PACKAGES_DIR, provider, "registry.json");

  if (!existsSync(registryPath)) {
    console.log(`âš ï¸  No registry found for ${provider}`);
    continue;
  }

  const registry: Registry = JSON.parse(readFileSync(registryPath, "utf-8"));

  console.log(`ðŸ“¦ Processing ${provider}:`);

  for (const item of registry.items) {
    // Determine if component is previewable based on conventions
    const isPreviewable =
      item.type === "registry:ui" ||
      (item.type === "registry:block" &&
        item.files?.some((f) => f.type === "registry:component"));

    if (!isPreviewable) {
      console.log(`   â­ï¸  Skipping ${item.name} (type: ${item.type})`);
      continue;
    }

    // Find the component file
    const componentFile = item.files?.find(
      (f) => f.type === "registry:component",
    );

    if (!componentFile) {
      console.log(`   âš ï¸  No component file for ${item.name}`);
      continue;
    }

    // Extract module path from registry path
    // e.g., "registry/default/clerk/sign-in-shadcn/sign-in.tsx" -> "clerk/sign-in-shadcn/sign-in"
    const pathParts = componentFile.path.split("/");
    const registryIndex = pathParts.indexOf("default");

    let modulePath: string;
    if (registryIndex !== -1) {
      // Has "default" in path (e.g., clerk, polar, logos, uploadthing)
      modulePath = pathParts
        .slice(registryIndex + 1)
        .join("/")
        .replace(/\.(tsx?|jsx?)$/, "");
    } else {
      // No "default" in path (e.g., theme-switcher)
      // Extract from "registry/theme-switcher/..." -> "theme-switcher/..."
      const regIndex = pathParts.indexOf("registry");
      if (regIndex === -1) {
        console.log(`   âš ï¸  Invalid path format for ${item.name}`);
        continue;
      }
      modulePath = pathParts
        .slice(regIndex + 1)
        .join("/")
        .replace(/\.(tsx?|jsx?)$/, "");
    }

    // Now adjust the module path based on the provider to match tsconfig paths
    // The tsconfig paths already point to the correct base directory:
    // @registry/clerk/* -> ../../packages/clerk/registry/clerk/*
    // @registry/theme/* -> ../../packages/theme/registry/theme-switcher/*
    // So we just need the path after that base directory

    let importPath: string;
    if (provider === "theme") {
      // Theme special case: registry/theme-switcher/button.tsx -> button
      importPath = modulePath.replace("theme-switcher/", "");
    } else {
      // Other providers: clerk/sign-in-shadcn/sign-in -> sign-in-shadcn/sign-in
      const providerPrefix = `${provider}/`;
      importPath = modulePath.startsWith(providerPrefix)
        ? modulePath.slice(providerPrefix.length)
        : modulePath;
    }

    // Generate unique import name
    const importName = item.name
      .split("-")
      .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
      .join("");

    // Add import statement
    imports.push(
      `import * as ${importName}Module from "@registry/${provider}/${importPath}";`,
    );

    // Add to mapping
    mappings.push(`  "${item.name}": ${importName}Module,`);

    console.log(`   âœ… ${item.name} -> @registry/${provider}/${importPath}`);
  }

  console.log();
}

// Generate the file content
const fileContent = `/**
 * AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 *
 * This file is automatically generated by scripts/generate-preview-map.ts
 * Run: bun run scripts/generate-preview-map.ts
 *
 * Convention-based component preview mappings:
 * - registry:ui components are previewable
 * - registry:block components with registry:component files are previewable
 * - Other types (lib, hook, etc.) are not previewable
 */

import type { ComponentType } from "react";

${imports.join("\n")}

interface ComponentModule {
  default?: ComponentType<any>;
  [key: string]: any;
}

export const componentPreviewMap: Record<string, ComponentModule> = {
${mappings.join("\n")}
};

/**
 * Get a component from the preview map.
 * Extracts the default export or first named component export.
 */
export function getPreviewComponent(name: string): ComponentType<any> | null {
  const module = componentPreviewMap[name];

  if (!module) {
    return null;
  }

  // Try default export first
  if (module.default) {
    return module.default;
  }

  // Find first function export (component)
  for (const [key, value] of Object.entries(module)) {
    if (typeof value === "function" && key !== "default") {
      return value as ComponentType<any>;
    }
  }

  return null;
}
`;

// Write the generated file
writeFileSync(OUTPUT_FILE, fileContent, "utf-8");

console.log(`âœ¨ Generated preview map: ${OUTPUT_FILE}`);
console.log(`ðŸ“Š Total previewable components: ${mappings.length}`);
